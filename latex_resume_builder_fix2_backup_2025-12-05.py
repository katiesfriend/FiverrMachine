#!/usr/bin/env python3
"""
latex_resume_builder.py

Takes a plaintext resume (our generated resume_jobXX.txt) and renders it
through a modern-ish LaTeX template to produce a PDF.

If pdflatex is missing or compilation fails, the caller should catch the
RuntimeError and fall back to a simpler PDF path.
"""

import os
import subprocess
from typing import List, Tuple


def _normalize_unicode(text: str) -> str:
    """
    Normalize common Unicode punctuation into LaTeX-friendly ASCII.
    This prevents classic "Unicode character U+XXXX not set up" errors.
    """
    replacements = {
        "\u2022": "*",    # bullet
        "\u2013": "-",    # en dash
        "\u2014": "-",    # long dash
        "\u201c": "\"",
        "\u201d": "\"",
        "\u201e": "\"",
        "\u2018": "'",
        "\u2019": "'",
        "\u2026": "...",
        "\u00a0": " ",    # non-breaking space
    }
    return "".join(replacements.get(ch, ch) for ch in text)


def _escape_latex(text: str) -> str:
    """
    Escape basic LaTeX special characters in a conservative way.
    Also normalizes Unicode punctuation first.
    """
    text = _normalize_unicode(text)

    replacements = {
        "\\": r"\textbackslash{}",
        "&": r"\&",
        "%": r"\%",
        "$": r"\$",
        "#": r"\#",
        "_": r"\_",
        "{": r"\{",
        "}": r"\}",
        "~": r"\textasciitilde{}",
        "^": r"\textasciicircum{}",
    }
    out: List[str] = []
    for ch in text:
        out.append(replacements.get(ch, ch))
    return "".join(out)


def _split_header_body(lines: List[str], header_lines: int = 3) -> Tuple[List[str], List[str]]:
    """
    Heuristic: first N non-empty lines are treated as the "header block"
    (name, title, contact line). Everything else is body.
    """
    non_empty_indices = [i for i, ln in enumerate(lines) if ln.strip()]
    if not non_empty_indices:
        return [], lines

    cutoff_count = min(header_lines, len(non_empty_indices))
    cutoff_index = non_empty_indices[cutoff_count - 1]

    header = lines[: cutoff_index + 1]
    body = lines[cutoff_index + 1 :]
    return header, body


def _build_resume_tex(content: str, doc_title: str | None = None) -> str:
    """
    Build a LaTeX source string for a clean, modern single-column resume.

    We treat the first 2-3 non-empty lines as a header and render them larger.
    The remaining lines are rendered as body text, preserving blank lines as
    vertical space.
    """
    raw_lines = content.splitlines()
    header_lines, body_lines = _split_header_body(raw_lines, header_lines=3)

    header_lines_esc = [_escape_latex(ln.strip()) for ln in header_lines if ln.strip()]
    body_lines_esc = [_escape_latex(ln.rstrip()) for ln in body_lines]

    header_block = ""
    if header_lines_esc:
        name = header_lines_esc[0]
        title_line = header_lines_esc[1] if len(header_lines_esc) > 1 else ""
        contact_line = header_lines_esc[2] if len(header_lines_esc) > 2 else ""

        header_block = r"""
\begin{center}
    {\fontsize{20}{22}\selectfont \textbf{""" + name + r"""}}\\[4pt]
"""

        if title_line:
            header_block += r"    {\large " + title_line + r"}\\[2pt]" + "\n"
        if contact_line:
            header_block += r"    {\small " + contact_line + r"}\\[4pt]" + "\n"

        header_block += r"\rule{0.9\textwidth}{0.4pt}" + "\n" + r"\end{center}" + "\n\n"

    # Body: blank lines become vertical space, not raw \\ to avoid "no line here to end"
    body_block_lines: List[str] = []
    for ln in body_lines_esc:
        if ln.strip() == "":
            body_block_lines.append(r"\par\vspace{0.6\baselineskip}")
        else:
            body_block_lines.append(ln + r"\\[0.1\baselineskip]")

    body_block = "\n".join(body_block_lines)

    title_comment = f"% {doc_title}\n" if doc_title else ""
    tex = r"""% Auto-generated by latex_resume_builder.py
""" + title_comment + r"""\documentclass[11pt]{article}
\usepackage[margin=0.8in]{geometry}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{enumitem}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    urlcolor=black,
    linkcolor=black
}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.2\baselineskip}

\begin{document}
""" + header_block + body_block + r"""

\end{document}
"""

    return tex


def render_plaintext_resume_to_pdf(txt_path: str, pdf_path: str, doc_title: str | None = "Tailored Resume") -> None:
    """
    Read a plaintext resume and compile a LaTeX PDF at pdf_path.

    Raises RuntimeError if pdflatex is unavailable or if no PDF is produced.
    """
    if not os.path.isfile(txt_path):
        raise RuntimeError(f"Resume text file does not exist: {txt_path}")

    with open(txt_path, "r", encoding="utf-8", errors="ignore") as f:
        content = f.read()

    job_dir = os.path.dirname(os.path.abspath(pdf_path))
    base_name = os.path.splitext(os.path.basename(pdf_path))[0]
    tex_name = base_name + ".tex"
    tex_path = os.path.join(job_dir, tex_name)

    tex_source = _build_resume_tex(content, doc_title=doc_title)

    # Write the .tex file
    with open(tex_path, "w", encoding="utf-8") as f:
        f.write(tex_source)

    compiled_pdf = os.path.join(job_dir, base_name + ".pdf")

    # Run pdflatex but do not treat non-zero return as fatal if a PDF is produced
    try:
        result = subprocess.run(
            ["pdflatex", "-interaction=nonstopmode", tex_name],
            cwd=job_dir,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=False,
        )
    except FileNotFoundError as e:
        raise RuntimeError("pdflatex is not installed or not on PATH") from e

    # If pdflatex failed and no PDF exists, then this is a real error
    if result.returncode != 0 and not os.path.isfile(compiled_pdf):
        msg = f"LaTeX compilation failed and no PDF was produced: returncode={result.returncode}"
        raise RuntimeError(msg)

    if not os.path.isfile(compiled_pdf):
        raise RuntimeError(f"Expected LaTeX output PDF not found: {compiled_pdf}")

    # If the compiled PDF path is not exactly the target, rename/move it
    if os.path.abspath(compiled_pdf) != os.path.abspath(pdf_path):
        os.replace(compiled_pdf, pdf_path)

    # Clean up aux/log files (best-effort)
    for ext in (".aux", ".log", ".out"):
        p = os.path.join(job_dir, base_name + ext)
        if os.path.exists(p):
            try:
                os.remove(p)
            except OSError:
                pass
